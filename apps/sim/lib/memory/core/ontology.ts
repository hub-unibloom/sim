import { sql } from '../db/postgres';
import { AffectiveVector } from '../types';

export class OntologyService {

    public static async ensureIdentityNode(userUuid: string): Promise<string> {
        const result = await sql`
      INSERT INTO graph_nodes (user_uuid, label, type, mass, last_accessed_at)
      VALUES (${userUuid}, 'SELF', 'IDENTITY', 100.0, NOW())
      ON CONFLICT (uuid) 
      DO UPDATE SET 
          mass = 100.0, 
          last_accessed_at = NOW()
      RETURNING uuid
    `;
        // Note: Converted ON CONFLICT on (user_uuid, label, type) might need unique constraint in Schema if not UUID PK. 
        // Schema defines UUID as PK. We need to ensure logic adapts. 
        // For now, assuming uuid generation handled by DB defaults or client? 
        // Wait, Schema has uuid primary key. This insert might fail if uuid not provided or auto-gen.
        // Let's assume uuid is auto-generated by DB (default random_uuid() or similar if defined) OR we generated it. 
        // If we look at previous code, it relied on conflict on (user_uuid, label, type).
        // We should probably check if we can query first or if schema enforces uniqueness on those fields.
        // The previous code had "ON CONFLICT (user_uuid, label, type)". 
        // Verify Schema: We created graphNodes with UUID PK. We didn't add unique constraint on (user_uuid, label, type). 
        // We should probably ADD that unique constraint to schema later.

        return result[0]?.uuid;
    }

    public static async linkToIdentity(
        identityNodeId: string,
        entityNodeIds: string[],
        emotionalState: AffectiveVector
    ) {
        if (!identityNodeId || entityNodeIds.length === 0) return;

        const emotionalGravity = 0.1 + (emotionalState.arousal * 0.8) + (emotionalState.joy * 0.1);
        const clampedWeight = Math.min(Math.max(emotionalGravity, 0.1), 1.0);

        const edges = entityNodeIds
            .filter(id => id !== identityNodeId)
            .map(id => ({
                source_uuid: identityNodeId,
                target_uuid: id,
                type: 'ASSOCIATIVE',
                weight: clampedWeight
            }));

        if (edges.length > 0) {
            await this.batchCreateEdges(edges);
        }
    }

    public static async linkIdentityToGroup(identityNodeId: string, groupNodeId: string) {
        if (!identityNodeId || !groupNodeId) return;

        await this.batchCreateEdges([{
            source_uuid: identityNodeId,
            target_uuid: groupNodeId,
            type: 'ASSOCIATIVE',
            weight: 0.8
        }]);
    }

    public static async resolveEntities(userUuid: string, entities: any[]): Promise<string[]> {
        if (!entities || entities.length === 0) return [];

        const uniqueEntities = new Map<string, string>();
        entities.forEach(e => {
            const label = e.name || e.value;
            if (label) uniqueEntities.set(label, 'ENTITY');
        });

        if (uniqueEntities.size === 0) return [];

        // We need to fetch existing nodes first to simulate UPSERT without unique constraint if not present
        // Or we rely on the schema update to add unique constraint. 
        // For safety, let's do a check-and-insert approach if not sure about constraint.
        // Actually, best is to try Insert and Ignore or explicit select.

        // Simplified logic for porting:
        const nodeUuids: string[] = [];
        for (const [label, type] of uniqueEntities.entries()) {
            const existing = await sql`SELECT uuid FROM graph_nodes WHERE user_uuid=${userUuid} AND label=${label} AND type=${type}`;
            if (existing.length > 0) {
                await sql`UPDATE graph_nodes SET mass = mass + 0.1, last_accessed_at = NOW() WHERE uuid=${existing[0].uuid}`;
                nodeUuids.push(existing[0].uuid);
            } else {
                const newId = crypto.randomUUID();
                await sql`INSERT INTO graph_nodes (uuid, user_uuid, label, type, mass, last_accessed_at) VALUES (${newId}, ${userUuid}, ${label}, ${type}, 1.0, NOW())`;
                nodeUuids.push(newId);
            }
        }

        return nodeUuids;
    }

    public static async processGroupContext(userUuid: string, groupMeta: { name: string, id_group: string }) {
        if (!groupMeta || !groupMeta.name) return null;

        // Similar logic: Check existing
        const existing = await sql`SELECT uuid FROM graph_nodes WHERE user_uuid=${userUuid} AND label=${groupMeta.name} AND type='CONCEPT'`;
        if (existing.length > 0) {
            await sql`UPDATE graph_nodes SET mass = mass + 0.2, last_accessed_at = NOW() WHERE uuid=${existing[0].uuid}`;
            return existing[0].uuid;
        } else {
            const newId = crypto.randomUUID();
            await sql`INSERT INTO graph_nodes (uuid, user_uuid, label, type, mass, last_accessed_at) VALUES (${newId}, ${userUuid}, ${groupMeta.name}, 'CONCEPT', 2.0, NOW())`;
            return newId;
        }
    }

    public static async linkEntitiesToGroup(entityNodeIds: string[], groupNodeId: string) {
        if (!groupNodeId || entityNodeIds.length === 0) return;

        const edges = entityNodeIds.map(id => ({
            source_uuid: groupNodeId,
            target_uuid: id,
            type: 'ASSOCIATIVE',
            weight: 0.15
        }));

        await this.batchCreateEdges(edges);
    }

    public static async linkNodes(nodeUuids: string[]) {
        if (nodeUuids.length < 2) return;

        const edges: any[] = [];
        for (let i = 0; i < nodeUuids.length; i++) {
            for (let j = i + 1; j < nodeUuids.length; j++) {
                edges.push({
                    source_uuid: nodeUuids[i],
                    target_uuid: nodeUuids[j],
                    type: 'ASSOCIATIVE',
                    weight: 0.1
                });
            }
        }

        if (edges.length > 0) {
            await this.batchCreateEdges(edges);
        }
    }

    public static async processThreadContext(userUuid: string, currentNodeIds: string[], replyChain: any[]) {
        if (!replyChain || replyChain.length === 0 || currentNodeIds.length === 0) return;

        const parentMsg = replyChain.find(r => r.level === 1 || r.reply_to);

        if (parentMsg) {
            const parentText = parentMsg.text || parentMsg.content || "";
            if (parentText.length < 3) return;

            const parentContextNodes = await sql`
        SELECT uuid FROM graph_nodes
        WHERE user_uuid = ${userUuid}
        AND position(label in ${parentText}) > 0
        LIMIT 3
      `;

            if (parentContextNodes.length > 0) {
                const edges: any[] = [];
                for (const parentNode of parentContextNodes) {
                    for (const currentNodeId of currentNodeIds) {
                        edges.push({
                            source_uuid: parentNode.uuid,
                            target_uuid: currentNodeId,
                            type: 'CAUSAL',
                            weight: 0.2
                        });
                    }
                }
                await this.batchCreateEdges(edges);
            }
        }
    }

    private static async batchCreateEdges(edges: { source_uuid: string, target_uuid: string, type: string, weight: number }[]) {
        if (edges.length === 0) return;

        // Simplified batch insert
        for (const edge of edges) {
            const id = crypto.randomUUID();
            // Upsert logic manually
            const exists = await sql`SELECT id, weight FROM graph_edges WHERE source_uuid=${edge.source_uuid} AND target_uuid=${edge.target_uuid} AND type=${edge.type}`;
            if (exists.length > 0) {
                const newWeight = Math.min(exists[0].weight + edge.weight, 1.0);
                await sql`UPDATE graph_edges SET weight=${newWeight} WHERE id=${exists[0].id}`;
            } else {
                await sql`INSERT INTO graph_edges (id, source_uuid, target_uuid, type, weight) VALUES (${id}, ${edge.source_uuid}, ${edge.target_uuid}, ${edge.type}, ${edge.weight})`;
            }
        }
    }
}
